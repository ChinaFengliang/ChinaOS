/******************************************************Copyright (c)**************************************************
**                                              胆怯是阻止一切可能的根本缘由
**
**                                             E-Mail: ChinaFengliang@163.com
**
**---------File Information-------------------------------------------------------------------------------------------
** File name:            bit.c
** Last version:         V1.00
** Descriptions:         位处理文件.
** Hardware platform:
** SoftWare platform:
**
**--------------------------------------------------------------------------------------------------------------------
** Created by:           FengLiang
** Created date:         2010年9月1日  13:56:29
** Version:              V1.00
** Descriptions:         The original version
**
**--------------------------------------------------------------------------------------------------------------------
** Modified by:          
** Modified date:
** Version:
** Descriptions:
**
*********************************************************************************************************************/

/*          msb                                                                                         lsb
           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
    位  图 |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |
           |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |  |
           +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

    位索引: 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 09 08 07 06 05 04 03 02 01 00         */

/*********************************************************************************************************************
                                                    头文件区
*********************************************************************************************************************/
#include    <include/types.h>


/*********************************************************************************************************************
                                                    宏定义区
*********************************************************************************************************************/
/* 宏段名 ----------------------------------------------------------------------------------------------------------*/


/*********************************************************************************************************************
                                                    类型定义区
*********************************************************************************************************************/
/* 基本类型 --------------------------------------------------------------------------------------------------------*/


/*********************************************************************************************************************
                                                  全局变量定义区
*********************************************************************************************************************/


/*********************************************************************************************************************
** Function name:           bit_algorithm_1
** Descriptions:
** Input parameters:
** Output parameters:
** Returned value:
**--------------------------------------------------------------------------------------------------------------------
** Created by:              Fengliang
** Created Date:            2010-11-3  17:13:37
** Test recorde:
**--------------------------------------------------------------------------------------------------------------------
** Modified by:
** Modified date:
** Test recorde:
*********************************************************************************************************************/
INT32U bit_algorithm_1(INT32U x)
{
    /* 假设: R = xxxx xxxx x100 0000, x可为'0'或者'1'.
     *
     * 1) 进行以下计算: r = R - 1.
     *          R  : xxxx xxxx x100 0000
     *      减  1  : 0000 0000 0000 0001
     *      ----------------------------
     *          r  : xxxx xxxx x011 1111
     *
     * 2) 进行以下计算: t = R ^ r.
     *          R  : xxxx xxxx x100 0000
     *      ^   r  : xxxx xxxx x011 1111
     *      ----------------------------
     *     result  : 0000 0000 0111 1111
     */
    return x ^= x - 1;
}

/*********************************************************************************************************************
** Function name:           bit_algorithm_2
** Descriptions:
** Input parameters:
** Output parameters:
** Returned value:
**--------------------------------------------------------------------------------------------------------------------
** Created by:              Fengliang
** Created Date:            2010-11-3  17:14:7
** Test recorde:
**--------------------------------------------------------------------------------------------------------------------
** Modified by:
** Modified date:
** Test recorde:
*********************************************************************************************************************/
INT32U bit_algorithm_2(INT32U x)
{
    /* 假设: R = xxxx xxxx x100 0000, x可为'0'或者'1'.
     *
     * 1) 进行以下计算:  r = (-R) = 0 - R.
     *          0  : 0000 0000 0000 0000
     *      减  R  : xxxx xxxx x100 0000
     *      ----------------------------
     *          r  : yyyy yyyy y100 0000
     *    说明 : y = ~x
     *
     * 2) 进行以下计算: result = R & r.
     *          R  : xxxx xxxx x100 0000
     *      与  r  : yyyy yyyy y100 0000
     *      ----------------------------
     *          t  : 0000 0000 0100 0000
     *
     * 3) 进行以下计算: number = result - 1.
     *          t  : 0000 0000 0100 0000
     *      减  1  : 0000 0000 0000 0001
     *      ----------------------------
     *      result : 0000 0000 0011 1111
     *
     * 4) 通过计算result值中'1'个数, 即可得出R后导零的个数
     */
    x = x & (-(INT32S)x);

    return x = x - 1;
}

/*********************************************************************************************************************
** Function name:           bit_count
** Descriptions:            计算二进制位'1'的个数
** Input parameters:        None
** Output parameters:       None
** Returned value:          位'1'的个数
**--------------------------------------------------------------------------------------------------------------------
** Created by:              Fengliang
** Created Date:            2010-9-1  13:54:56
** Test recorde:
**--------------------------------------------------------------------------------------------------------------------
** Modified by:
** Modified date:
** Test recorde:
*********************************************************************************************************************/
INT32S  bit_count(INT32U R0)
{
    INT32U      R2;
    INT32U      R1 = 0x49249249;                                            /* LDR  R1, =0x49249249                 */

    R2 = R0 & (R1 << 1);                                                    /* AND  R2, R0, R1, LSL #1              */
    R0 = R0 - (R2 >> 1);                                                    /* SUB  R0, R0, R2, LSR #1              */
    R2 = R0 & (R1 >> 1);                                                    /* AND  R2, R0, R1, LSR #1              */
    R0 = R0 + R2;                                                           /* ADD  R0, R0, R2                      */

    R1 = 0xc71c71c7;                                                        /* LDR  R1, =0xc71c71c7                 */
    R0 = R0 + (R0 >> 3);                                                    /* ADD  R0, R0, R0, LSR #3              */
    R0 = R0 & R1;                                                           /* AND  R0, R0, R1                      */

    R0 = R0 + (R0 >> 6);                                                    /* ADD  R0, R0, R0, LSR #6              */
    R0 = R0 + (R0 >> 12);                                                   /* ADD  R0, R0, R0, LSR #12             */
    R0 = R0 + (R0 >> 24);                                                   /* ADD  R0, R0, R0, LSR #24             */
    R0 = R0 & 0x3F;                                                         /* AND  R0, R0, #63                     */

    return R0;
}

/*********************************************************************************************************************
** Function name:           bit_scan_forward
** Descriptions:            逐位正扫描(从lsb至msb扫描)
** Input parameters:        R0 : 标识
** Output parameters:       
** Returned value:          后导'0'个数
**--------------------------------------------------------------------------------------------------------------------
** Created by:              Fengliang
** Created Date:            2011-3-26  18:51:57
** Test recorde:            通过测试 bit_scan_forward(0x12); Returned value: 1.
**--------------------------------------------------------------------------------------------------------------------
** Modified by:
** Modified date:
** Test recorde: 
*********************************************************************************************************************/
INT32U bit_scan_forward(INT32U R0)
{
#if 1
    /* 方案一 ------------------------------------------------------------------------------------------------------*/
    INT32U      R1;
    INT32U      R2;

    /* 假设: R = xxxx xxxx x100 0000, x可为'0'或者'1'.
     *
     * 1) 进行以下计算:  r = (-R) = 0 - R.
     *          0  : 0000 0000 0000 0000
     *      减  R  : xxxx xxxx x100 0000
     *      ----------------------------
     *          r  : yyyy yyyy y100 0000
     *    说明 : y = ~x
     *
     * 2) 进行以下计算: result = R & r.
     *          R  : xxxx xxxx x100 0000
     *      与  r  : yyyy yyyy y100 0000
     *      ----------------------------
     *          t  : 0000 0000 0100 0000
     *
     * 3) 进行以下计算: number = result - 1.
     *          t  : 0000 0000 0100 0000
     *      减  1  : 0000 0000 0000 0001
     *      ----------------------------
     *      result : 0000 0000 0011 1111
     *
     * 4) 通过计算result值中'1'个数, 即可得出R后导零的个数
     */
    R0 = R0 & (-(INT32S)R0);
    R0--;

    /*
     * 计算result值中'1'个数
     */
    R1 = 0x49249249;                                                        /* LDR  R1, =0x49249249                 */
    R2 = R0 & (R1 << 1);                                                    /* AND  R2, R0, R1, LSL #1              */
    R0 = R0 - (R2 >> 1);                                                    /* SUB  R0, R0, R2, LSR #1              */
    R2 = R0 & (R1 >> 1);                                                    /* AND  R2, R0, R1, LSR #1              */
    R0 = R0 + R2;                                                           /* ADD  R0, R0, R2                      */

    R1 = 0xc71c71c7;                                                        /* LDR  R1, =0xc71c71c7                 */
    R0 = R0 + (R0 >> 3);                                                    /* ADD  R0, R0, R0, LSR #3              */
    R0 = R0 & R1;                                                           /* AND  R0, R0, R1                      */

    R0 = R0 + (R0 >> 6);                                                    /* ADD  R0, R0, R0, LSR #6              */
    R0 = R0 + (R0 >> 12);                                                   /* ADD  R0, R0, R0, LSR #12             */
    R0 = R0 + (R0 >> 24);                                                   /* ADD  R0, R0, R0, LSR #24             */
    R0 = R0 & 0x3F;                                                         /* AND  R0, R0, #63                     */

    return R0;
#endif

    /* 方案二 ------------------------------------------------------------------------------------------------------*/
#if 0
int get_first_one_index(unsigned int X)
{
  unsigned int Y = X - 1;
  unsigned int K = Y >> 12 & 16;
  unsigned int N = K;
  
  Y >>= K;
  N += K = Y >> 5 & 8;
  Y >>= K;
  N += K = Y >> 2 & 4;
  Y >>= K;
  N += K = Y >> 1 & 2;
  Y >>= K;
  N += K = Y >> 1 & 1;
  Y >>= K;
  return N + Y;
#endif

}

/*********************************************************************************************************************
** Function name:           bit_scan_reverse
** Descriptions:            逐位逆扫描(从msb至lsb扫描)
** Input parameters:        R0 : 标识
** Output parameters:       
** Returned value:          前导'0'个数
**--------------------------------------------------------------------------------------------------------------------
** Created by:              Fengliang
** Created Date:            2011-3-26  18:51:57
** Test recorde:            
**--------------------------------------------------------------------------------------------------------------------
** Modified by:
** Modified date:
** Test recorde: 
*********************************************************************************************************************/
INT32U bit_scan_reverse(INT32U R0)
{
#if 0
    /* 方案一 ------------------------------------------------------------------------------------------------------*/
    CLZ R0,     R0                                                          /* ARM 汇编指令                         */
#endif

    return R0;
}

/*********************************************************************************************************************
** Function name:           bit32_order_reverse
** Descriptions:            32位序反转
** Input parameters:        x : 操作数
** Output parameters:       none
** Returned value:          经颠倒后的结果
**--------------------------------------------------------------------------------------------------------------------
** Created by:              Fengliang
** Created Date:            2010-11-3  16:54:57
** Test recorde:
**--------------------------------------------------------------------------------------------------------------------
** Modified by:
** Modified date:
** Test recorde:
*********************************************************************************************************************/
INT32U bit32_order_reverse(INT32U x)
{
    x = (x >> 16) | (x << 16);
    x = (x >> 8 & 0x00ff00ff) | (x << 8 & 0xff00ff00);
    x = (x >> 4 & 0x0f0f0f0f) | (x << 4 & 0xf0f0f0f0);
    x = (x >> 2 & 0x33333333) | (x << 2 & 0xcccccccc);
    x = (x >> 1 & 0x55555555) | (x << 1 & 0xaaaaaaaa);

    return x;
}

/*********************************************************************************************************************
** Function name:           bit8_order_reverse
** Descriptions:            8位序反转
** Input parameters:        x : 操作数
** Output parameters:       none
** Returned value:          经颠倒后的结果
**--------------------------------------------------------------------------------------------------------------------
** Created by:              Fengliang
** Created Date:            2010-11-3  16:54:57
** Test recorde:
**--------------------------------------------------------------------------------------------------------------------
** Modified by:
** Modified date:
** Test recorde:
*********************************************************************************************************************/
INT8U  bit8_order_reverse(INT8U x)
{
    x = (INT8U)((x >> 4) | (x << 4));
    x = (INT8U)((x >> 2 & 0x33) | (x << 2 & 0xcc));
    x = (INT8U)((x >> 1 & 0x55) | (x << 1 & 0xaa));

    return x;
}

/*********************************************************************************************************************
                                                    END OF FILE
*********************************************************************************************************************/

